<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <title>wxg的小站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,
            maximum-scale=1">

    <link type="text/css" rel="stylesheet" href="/syntaxhighlighter/styles/shCoreDefault.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/webfonts/ptserif/main.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPerl.js"></script>

    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <style>
        .syntaxhighlighter table {
            font-size: 14px !important;
            overflow: hidden !important;
            background-color: aliceblue !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <header id="header">
            <div id="header-outer" class="outer" style="">
                <div id="header-inner" class="inner" style="margin-top: 10px;">
                    <a href="/" style="font-size:24px; color: black; margin-right: 10px;">Home</a>
                    <a href="/books/algorithm/_book/" style="font-size:24px; color: black; margin-right: 10px;">Book</a>
                    <a href="/blogs/me.html" style="font-size:24px; color: black;">About</a>
                    <nav id="main-nav">
                    </nav>
                </div>
            </div>
        </header>
        <section id="main" class="outer">

            <article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/12/libevent-cpp-5-封装epoll及epoll内核实现原理.html">libevent-cpp-5-封装epoll及epoll内核实现原理</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/12/libevent-cpp-5-封装epoll及epoll内核实现原理.html" class="article-date">
                <time itemprop="datePublished">2018年12月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>前面介绍了poll和select在内核中的实现原理，可以说本质上两者都是相同的，都是将用户空间的文件描述符及对应事件复制到内核空间，然后在内核空间轮询，如果轮询没有事件，则将当前进程置于该文件描述符的等待队列，如此，在之后该文件进行读写操作时就可以唤醒其等待队列，然后再次轮询时会发现发生了读或者写事件。但是轮询机制在大规模IO复用时会有着明显的缺陷，首先因为poll和select要不断的轮询，所以其时间复杂度为O(n)，随着文件描述符的增多会越来越慢，另外文件描述符的增多也会导致要从用户态拷贝到内核态的数据越来越多，在大规模IO复用中，这种拷贝多次执行显然是难以忍受的，可以说基于poll种种缺点，在Linux-2.6版本左右加入了epoll机制，能够非常高高效的进行IO复用。</p>
<p>首先针对IO复用这一机制，从原理上来说其实主要的几个思路是不会改变的。首先是用户程序需要将其关注的文件描述符或者相应的读写事件传递给内核，不做处理的话这里存在从用户态到内核态的拷贝，select和poll就是这么做的，其次比较关键的其实就是内核在获取了相应的文件描述符及事件之后，如何有针对性的监控该文件描述符是否发生事件，并根据有无来进行当前进程睡眠和唤醒，因为如果没有发生事件的话是需要释放cpu资源的。在引入epoll之前的Linux版本中，或者说在2.6以前的版本中，poll对进程的睡眠是通过一个<code>poll_wait</code>函数实现的，只要是实现了poll函数的虚拟文件系统，都会在<code>poll</code>中调用<code>poll_wait</code>，poll会将当前进程置于该文件的等待队列，然后在该虚拟文件系统的读写接口中会相应的进行等待队列进程的唤醒。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/12/libevent-cpp-4-封装poll及poll内核实现原理.html">libevent-cpp-4-封装poll及poll内核实现原理</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/12/libevent-cpp-4-封装poll及poll内核实现原理.html" class="article-date">
                <time itemprop="datePublished">2018年12月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>随着Linux的更新在linux-2.1.23版本中加入了poll机制，因为poll的加入导致select的实现变得基于poll了，本文在上一个版本的基础上在libevent-cpp中加入了对poll机制的封装。总的来说，主要介绍libevent-cpp poll机制以及Linux内核对poll机制的实现原理，另外还会介绍到内核中select实现因为poll而做的改变。</p>
<h2><a data-uk-modal="{target:'#category-id'}">读写事件管理及poll机制</a></h2>

<h3><a data-uk-modal="{target:'#category-id'}">poll机制</a></h3>

<p>如下为<code>poll</code>库函数，接收的数据<code>struct pollfd *fds</code> 其实是一个<code>strucct pollfd</code> 类型的数组，<code>nfds</code>对应着数组中元素的个数，最后一个为超时。与select最大的区别在于将关注的文件描述符以及对应的事件都抽取出来整合成<code>struct pollfd</code>类型了，而select需要一个很大的文件描述符集合数组，而其中可能只有很少的几个描述符是我们关注的可能会有读写事件。所以从功能上来说<code>poll</code>其实是更高效的。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/12/libevent-cpp-3-读写事件及Linux内核select机制实现原理.html">libevent-cpp-3-读写事件及Linux内核select机制实现原理</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/12/libevent-cpp-3-读写事件及Linux内核select机制实现原理.html" class="article-date">
                <time itemprop="datePublished">2018年12月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>关于libevent除了对于信号和超时的处理，最核心的部分其实是对于多路IO复用的封装。IO复用存在多种方式，包括select、poll、kqueue及epoll等多种接口。libevent的实现中用C语言以类似面向对象的方式来将这多种IO复用方式进行封装，对于我们的libevent-cpp而言，可以直接使用父子继承来实现各种不同的IO方式。本文主要介绍一下select机制以及libevent中使用select来处理IO读写事件的方式，然后深入Linux内核介绍一下select的实现机制。</p>
<h2><a data-uk-modal="{target:'#category-id'}">读写事件管理及select机制</a></h2>

<p></p>
<h3><a data-uk-modal="{target:'#category-id'}">select机制</a></h3>

<p>如下为select函数及对应的参数，参数中最重要的数据类型就是fd_set数组对应的读描述符集合和写描述符集合，其中分别保存着读写描述符的信息，进程首先会睡眠于select函数，之后一旦读或者写描述符集合中的某个fd满足读或者写了，那么select就会返回，然后进程处理对应描述符的读写。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/11/中缀表达式转后缀求值并打印树结构.html">中缀表达式转后缀求值并打印树结构</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/11/中缀表达式转后缀求值并打印树结构.html" class="article-date">
                <time itemprop="datePublished">2018年11月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>题目内容：众所周知，任何一个表达式，都可以用一棵表达式树来表示。例如，表达式a+b*c，可以表示为如下的表达式树。现在，给你一个中缀表达式，这个中缀表达式用变量来表示（不含数字），请你将这个中缀表达式用表达式二叉树的形式输出出来。</p>
<pre class="brush: ;">
   +
  / \
 a   *
    / \
    b c
</pre>
<h4><a data-uk-modal="{target:'#category-id'}">输入格式:</a></h4>

<p>输入分为三个部分。</p>
<p>第一部分为一行，即中缀表达式(长度不大于50)。中缀表达式可能含有小写字母代表变量（a-z），也可能含有运算符（+、-、*、/、小括号），不含有数字，也不含有空格。</p>
<p>第二部分为一个整数n(n < 10)，表示中缀表达式的变量数。</p>
<p>第三部分有n行，每行格式为C　x，C为变量的字符，x为该变量的值。</p>
<h4><a data-uk-modal="{target:'#category-id'}">输出格式：</a></h4>

<p>输出分为三个部分，第一个部分为该表达式的逆波兰式，即该表达式树的后根遍历结果。占一行。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/11/libevent-cpp-2-事件重构及时间处理.html">libevent-cpp-2-事件重构及时间处理</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/11/libevent-cpp-2-事件重构及时间处理.html" class="article-date">
                <time itemprop="datePublished">2018年11月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>上一篇介绍主要关于libevent的基本架构，并以C++的方式重写了其中的信号机制，在事件本身的结构还没有进行过多的抽象。在原本的libevent中，事件的类型是由 <code>ev_events</code> 来决定的，而事件所处的状态是由 <code>ev_flags</code> 来决定的。但是客观上来说，不同类型的事件之间的处理方式差别还是挺大的，因而可以分别以不同类进行抽象处理。这篇文章主要在进行事件抽象的基础上增加了时间处理，能够对超时事件进行响应。</p>
<h2><a data-uk-modal="{target:'#category-id'}">重构事件的起源-event类</a></h2>

<p>从重构的角度来看，对于信号事件、时间时间和读写事件应该分别进行抽象，并将尽可能相同的功能放到基类event中，所以就暂时有了如下的event：</p>
<pre class="brush: c++;">
class event
{
  public:
	event_base *_base;
	short _events; /* EV_TIMEOUT EV_READ EV_WRITE EV_SIGNAL EV_PERSIST */
	short _ncalls = 0;
	int _pri; /* smaller numbers means higher priority */

	void (*_callback)(short, void *arg);
	int _res; /* result passed to event callback */

  public:
	event(event_base *base);
	virtual ~event() { std::cout < <  __func__ < <  std::endl; }

	void set_base(event_base *base) { _base = base; }
	void set_callback(void (*callback)(short, void *)) { _callback = callback; }

	virtual void add() {}
	virtual void del() {}

	void activate(int res, short ncalls);
};
</pre>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/11/libevent-cpp-1-基本架构及信号处理.html">libevent-cpp-1-基本架构及信号处理</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/11/libevent-cpp-1-基本架构及信号处理.html" class="article-date">
                <time itemprop="datePublished">2018年11月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>Libevent是一个事件通知库，其API提供了一种机制用于在文件描述符上发生特定事件或者超时之后执行回调函数，此外，libevent还支持因为信号或常规超时引起的回调操作。libevent 旨在替换事件驱动的网络f服务器中的事件循环，应用程序只需要调用 <code>event_dispatch</code> ，然后动态添加或删除事件，而不需要更改事件循环。</p>
<p>Libevent 是用C语言编写的高性能网路库，这里尝试使用C++进行封装其中的接口，目前主要基于 libevent-1.1b 版本的代码。本文在简介libevent基本架构的同时主要分析libevent中对于信号的处理方式。本文C++封装代码可在<a href="https://github.com/sharixos/libevent-cpp">libevent-cpp</a> 找到。</p>
<h2><a data-uk-modal="{target:'#category-id'}">Libevent 基本架构</a></h2>

<p>Libevent中最关键的数据类型就是事件<code>event</code>和事件管理器，事件管理器其实就是<code>event_bas</code>。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/11/Linux-信号机制-signal.html">Linux-信号机制-signal</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/11/Linux-信号机制-signal.html" class="article-date">
                <time itemprop="datePublished">2018年11月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>信号是类Unix系统中一种常用的IPC机制，信号是发送到进程或同一进程内的特定线程的异步通知，以便通知它发生的事件。当信号发出时，操作系统会终端目标进程的执行流来传递信号，任何非原子的执行过程都可以被中断，如果进程之前已经注册过信号处理函数，该处理函数就会被调用，否则会执行默认的信号处理函数。信号和中断类似，区别是中断是由硬件调停并由内核处理，而信号是由内核调停而由进程处理。内核可能将某些中断当作信号传给进程，比如 SIGSEGV、SIGBUS、SIGILL以及SIGFPE等。</p>
<ul><li>当其它进程调用像 <code>kill</code> 这样的函数时</li>
<li>使用 <code>abort</code> 之类的函数从进程自身发送信号</li>
<li>子进程退出时操作系统发送 SIGCHLD 信号</li>
<li>父进程死亡或在控制终端监测到挂起时发送 SIGHUP 信号</li>
<li>用户从键盘中断程序时发送 SIGINT 信号</li>
<li>当程序行为不正确时发送 SIGILL、SIGFPE和 SIGSEGV 之一</li>
<li>当程序访问 <code>mmap</code> 映射的但是不可用的内存时</li>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2018/11/C标准库-2-之工具.html">C标准库-2-之工具</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2018/11/C标准库-2-之工具.html" class="article-date">
                <time itemprop="datePublished">2018年11月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>GNU C标准库提供了很多工具用来简化编程，包括各种数学工具，对于时间的处理接口以及对系统资源的访问等等。本部分为GNU C标准库阅读记录第二部分，主要包括像随机数、浮点运算操作及定时时钟设置以及进程自己睡眠等操作。</p>
<h2><a data-uk-modal="{target:'#category-id'}">Mathematics</a></h2>

<p>标准库在<code>math.h</code> 头文件中声明了包括三角函数在内的很多数学函数用来计算，而在 <code>complex.h</code> 中提供了对复数的支持以及各种用于复数的计算。针对浮点类型的函数提供了三种变体，分别是对 <code>double</code>、<code>float</code>和<code>long double</code> 的支持，其中 <code>float</code>的计算是最快的，另外两个分别精度比较高。</p>
<p>以三角函数为例，分别存在<code>sin</code> 、<code>sinf</code> 和<code>sinl</code> 这三个函数，针对 <code>double</code> 、<code>float</code> 和 <code>long double</code> 进行计算。对于复数的支持函数一般叫做如 <code>ccos</code>和 <code>ctan</code> 等，后缀如<code>ccosf</code>同样表示对<code>float</code>的支持。反三角函数如反正弦函数位 <code>asin</code> ，三角函数中还有如双曲正弦函数 <code>sanh</code>等。</p>

        </div>

    </div>

</article><nav id="page-nav"><a class="extend prev" rel="prev" href="/">&laquo; Prev</a>
<a class="page-number" href="/">1</a>
<span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a>
<a class="page-number" href="/page/4/">4</a>
<a class="page-number" href="/page/5/">5</a>
<a class="page-number" href="/page/6/">6</a>
<a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
</nav>

        </section>
        <footer id="footer">

            <div class="outer">
                <div id="footer-info" class="inner">
                    &copy; 2019 Wang Xingang.&nbsp; Powered by <a href="https://github.com/wxggg/libevent-cpp"
                        target="_blank">libevent-cpp</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
                </div>
            </div>
        </footer>


    </div>
</body>

</html>
Leetcode上面很多关于基本运算操作的题目，模拟数的加减乘除之类的操作，很多都需要考虑溢出情况。

# 1. 判断回文数
判断回文数首先明确负数和末尾为0的数肯定不是回文数，其次就是借助sum来获取x的右半部分的逆置，这里要区分x的位数为基数和偶数的情况，导致判断条件有两个。当然也可以将x完全逆置，这样稍慢，而且完全逆置的话可能还会存在数的溢出情况。

```c++
bool isPalindrome(int x) {
    if (x < 0 || (x > 0 && x % 10 == 0)) return false;
    int sum = 0;
    while (sum < x) {
        sum = sum * 10 + x % 10;
        x /= 10;
    }
    return (sum == x) || (sum / 10 == x);
}
```

# 2. 数的逆置
数在逆置过程中可能存在溢出的情况，所以这里用long来暂存结果，并且最终判断long和int类型的大小范围。

```c++
int reverse(int x) {
    long res = 0;
    while (x) {
        res = res * 10 + x % 10;
        x /= 10;
    }
    return (res > INT32_MAX || res < INT32_MIN) ? 0 : res;
}
```

# 3. 除法
整数除法有可能产生溢出结果的情况只有一种，那就是当被除数为INT32_MIN而除数为-1的时候，这时候结果超过了INT32_MAX。另外在运算过程中因为要借助绝对值进行运算，而INT32_MIN在取绝对值时也会溢出，所以仍然需要借助long来保存中间变量。

另外这里题目中要求不能使用乘除操作，所以借助中间变量v和i（v=b*i）。

```c++
int divide(int dividend, int divisor) {
    if (dividend == INT32_MIN && divisor == -1) return INT32_MAX;

    long a = labs(dividend), b = labs(divisor), res = 0;
    long i = 1, v = b;
    while (v < a) v <<= 1, i <<= 1;

    while (a >= b) {
        while (a >= v) a -= v, res += i;
        v >>= 1, i >>= 1;
    }
    return (dividend > 0) == (divisor > 0) ? res : -res;
}
```

# 4. 加法
加法题目一般为大数加法，有借助链表、vector的，也有通过string来计算的。本质都是一样的，借助一个extra来保存进位信息，并且while循环判断三个条件，只有在两个参数都加完了并且没有进位了才会退出循环。

链表大数加法：
```c++
ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    ListNode head(0), *p = &head;
    int extra = 0;
    while (l1 || l2 || extra) {
        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + extra;
        extra = sum / 10;
        p->next = new ListNode(sum % 10);
        p = p->next;
        l1 = l1 ? l1->next : NULL;
        l2 = l2 ? l2->next : NULL;
    }
    p->next = NULL;
    return head.next;
}
```

字符串大数加法：
```c++
string add(const string &num1, const string &num2) {
    string res(1 + max(num1.size(), num2.size()), '0');
    int i1 = num1.length() - 1, i2 = num2.length() - 1;
    int extra = 0, p = res.size() - 1;
    while (i1 >= 0 || i2 >= 0 || extra) {
        int sum = (i1 >= 0 ? num1[i1] - '0' : 0) +
                  (i2 >= 0 ? num2[i2] - '0' : 0) + extra;
        extra = sum / 10;
        res[p--] = '0' + sum % 10;
        i1 = i1 >= 0 ? i1 - 1 : -1;
        i2 = i2 >= 0 ? i2 - 1 : -1;
    }
    return res.substr(p + 1);
}
```

数组大数加1：
```c++
vector<int> plusOne(vector<int> &digits) {
    int extra = 1;
    for (int i = digits.size() - 1; i >= 0 && extra > 0; i--) {
        digits[i] += extra;
        extra = digits[i] / 10;
        digits[i] = digits[i] % 10;
    }
    if (extra > 0) digits.insert(digits.begin(), extra);
    return digits;
}
```

字符串二进制加法：
```c++
string addBinary(string a, string b) {
    string res;
    int i = a.length() - 1, j = b.length() - 1;
    int extra = 0;
    while (i >= 0 || j >= 0 || extra) {
        int sum = (i >= 0 ? a[i] - '0' : 0) + (j >= 0 ? b[j] - '0' : 0) + extra;
        extra = sum / 2;
        res = char('0' + sum % 2) + res;
        i = i >= 0 ? i - 1 : -1;
        j = j >= 0 ? j - 1 : -1;
    }
    return res;
}
```

# 5. 乘法
大数的乘法可以分解为数和单个数字的乘法和大数加法的子操作。

```c++
string multiply(const string &num, char c) {
    if (c == '0' || num.empty() || num == "0") return "0";
    string res(num.size() + 1, '0');
    int k = c - '0', i = num.size() - 1, extra = 0, p = res.size() - 1;
    while (i >= 0 || extra) {
        int sum = (i >= 0 ? num[i] - '0' : 0) * k + extra;
        extra = sum / 10;
        res[p--] = '0' + sum % 10;
        i = i >= 0 ? i - 1 : -1;
    }
    return res.substr(p + 1);
}

string multiply(string num1, string num2) {
    if (num1.size() < num2.size()) swap(num1, num2);
    string res;
    for (const auto &c : num2) res = add(res + '0', multiply(num1, c));
    return res;
}
```

# 6. 阶乘和开方
在计算数的阶乘时，首先要考虑x和n分别为0的情况，然后需要考虑阶数n小于0的情况，将其转换为n大于0，在此之前还得考虑溢出情况，一般在INT32_MIN进行符号转换的时候都需要考虑溢出情况。

最后为了减少递归次数，要尽可能的将计算转换为底为x*x和阶为n/2的情况，这样能够将时间复杂度从O(n)减少为O(n/2)。

```c++
double myPow(double x, int n) {
    if (x == 0.0) return 0.0;
    if (n == INT32_MIN) return 1.0 / x * myPow(1.0 / x, INT32_MAX);
    if (n < 0) return myPow(1.0 / x, -n);
    if (n == 0) return 1;
    return n % 2 == 0 ? myPow(x * x, n / 2) : x * myPow(x, n - 1);
}
```

求开方的过程就是一个二分查找的过程，最重要的是在需要判断的时候不能直接进行 (y*y)与x的判断，因为(y*y)有可能产生溢出，应该选择(x/y)与y进行比较。
```c++
int mySqrt(int x) {
    int left = 0, right = x / 2 + 1;
    while (right - left > 1) {
        int mid = (left + right) / 2;
        if (x / mid < mid)
            right = mid;
        else
            left = mid;
    }
    if (x / right >= right) return right;
    return left;
}
```

# 7. 罗马数字转换

```c++
int romanToInt(string s) {
    unordered_map<char, int> m = {'I', 1},   {'V', 5},   {'X', 10},  {'L', 50},
                                  {'C', 100}, {'D', 500}, {'M', 1000};
    int res = 0, i;
    for (i = 0; i < s.length() - 1; i++) {
        if (m[s[i]] < m[s[i + 1]])
            res -= m[s[i]];
        else
            res += m[s[i]];
    }
    res += m[s[i]];
    return res;
}

string toroman(int n, char c10, char c5, char c1) {
    string res;
    if (n == 9)
        res += c1 + c10;
    else if (n >= 5)
        res += c5 + string(n - 5, c1);
    else if (n == 4)
        res += c1 + c5;
    else
        res += string(n, c1);
    return res;
}

string intToRoman(int num) {
    string res = "";
    res += string(num / 1000, 'M');
    res += toroman((num % 1000) / 100, 'M', 'D', 'C');
    res += toroman((num % 100) / 10, 'C', 'L', 'X');
    res += toroman(num % 10, 'X', 'V', 'I');
    return res;
}
```
首先lower_bound本身是具备二分查找的功能的，还存在其他类型的查找。如果是顺序数组查询的话都可以采用lower_bound进行二分查找。

# 1. 查找target的左右下标
```c++
vector<int> searchRange(vector<int> &nums, int target) {
    auto low = std::lower_bound(nums.begin(), nums.end(), target);
    if (low == nums.end() || *low != target) return {-1, -1};
    auto high = std::upper_bound(nums.begin(), nums.end(), target);
    return {low - nums.begin(), high - nums.begin() - 1};
}
```

# 2. 查找旋转数组

对于leetcode上的题目：一个顺序数组绕某个元素被旋转了，也可以采用二分查找，但是不能直接使用lower_bound，二分判断的时候有一个非常重要的问题，首先就是如果只有两个数的话，mid和left是相等的，这里需要单独处理，可以直接将left++。另外如果数组存在重复元素的话，在找到的中间元素与left相等时，也就是不能够区分mid在左半边还是右半边的话，也可以直接将left++。存在重复元素可能会导致最坏复杂度为O(n)。
```c++
int search(vector<int> &nums, int target) {
    int left = 0, right = nums.size() - 1, mid;
    while (left <= right) {
        mid = (left + right) / 2;
        if (nums[mid] == target) return mid;
        if (nums[mid] > nums[left]) {
            if (nums[left] <= target && target < nums[mid])
                right = mid - 1;
            else
                left = mid + 1;
        } else if (nums[mid] < nums[left]) {
            if (nums[mid] < target && target <= nums[right])
                left = mid + 1;
            else
                right = mid - 1;
        } else
            left++;
    }
    return -1;
}
```

# 3. 乱序数组查找第k大值

对于乱序数组，查找第k大的值，简单的方式是直接进行排序，但是这样复杂度较高，高效的方式是利用stl提供的nth_element函数，算法本质上利用partition，通过不断的将数组划分，最终使得第k大的元素左边更小，右边都更大。

对于非常大量的乱序数据要找到第k大的值，可以借助堆，维护一个元素个数为k的最大堆，遍历全部数据，当值比最大堆中的最大元素小时，替换最大堆的堆顶，然后调整堆。

如果数据量不大，并且存在大量重复元素，可以用map保存每个数据出现的次数，最后从小到大借助出现的次数来计算第k个数。

# 4. 两个有序数组找第k大值

对于两个数组要找第k大的值，简单的方式利用归并，复杂度较高，数组有序可以进行二分。在二分查找的时候主要要考虑不同的情况，为了效率还需要进行剪枝。

```c++
int findKth(vector<int> &nums1, int i, int r1, vector<int> &nums2, int j,
            int r2, int k) {
    if (i > r1) return nums2[j + k - 1];
    if (j > r2) return nums1[i + k - 1];

    if (i + k - 1 < r1) r1 = i + k - 1;
    if (j + k - 1 < r2) r2 = j + k - 1;

    if (nums1[r1] <= nums2[j]) {
        int size1 = r1 - i + 1;
        return k <= size1 ? nums1[i + k - 1] : nums2[j + k - size1 - 1];
    }
    if (nums2[r2] <= nums1[i]) {
        int size2 = r2 - j + 1;
        return k <= size2 ? nums2[j + k - 1] : nums1[i + k - size2 - 1];
    }

    int m1 = (i + r1) / 2, m2 = (j + r2) / 2;
    int leftsize1 = m1 - i + 1, leftsize2 = m2 - j + 1;
    if (nums1[m1] > nums2[m2]) {
        if (leftsize1 + leftsize2 > k)
            return findKth(nums1, i, m1 - 1, nums2, j, r2, k);
        else
            return findKth(nums1, i, r1, nums2, m2 + 1, r2, k - leftsize2);
    } else {
        if (leftsize1 + leftsize2 > k)
            return findKth(nums1, i, r1, nums2, j, m2 - 1, k);
        else
            return findKth(nums1, m1 + 1, r1, nums2, j, r2, k - leftsize1);
    }
}
```

# 5. 乱序数组查找缺失的最小整数

遍历数组，在每个访问的元素v上面都将其与下标为v-1的元素交换，直到二者相等，继续下一个

```c++
int firstMissingPositive(vector<int> &nums) {
    int i = 0;
    while (i < nums.size())
        if (nums[i] > 0 && nums[i] <= nums.size() &&
            nums[nums[i] - 1] != nums[i])
            swap(nums[nums[i] - 1], nums[i]);
        else
            ++i;

    for (int i = 0; i < nums.size(); i++)
        if (i + 1 != nums[i]) return i + 1;
    return nums.size() + 1;
}
```
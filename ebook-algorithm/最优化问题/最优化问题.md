最优化问题目标要求满足某种要求的最优解，一般采用动态规划和贪心算法求解。

# 1. 求子数组和最大的最优解

对于最优解，一般都会用一个变量来保存临时结果，这里tmp保存前几个连续数的和，如果和小于0的话，直接更新为下一个值，否则加上下一个值。

```c++
int maxSubArray(vector<int> &nums) {
    if (nums.empty()) return 0;
    int res = nums[0], tmp = nums[0]2;
    for (int i = 1; i < nums.size(); i++) {
        if (tmp < 0)
            tmp = nums[i];
        else
            tmp += nums[i];
        if(tmp > res) res = tmp;
    }
    return res;
}
```

# 2. 取两条边作为容器，能装水的最大值
同样使用临时变量保存目前最优值，然后更新下标，更新下标时可以直接更新到左右边高度都比之前的高度高就够了，因为往中间求解宽度只会越来越窄，只能选择更高的高度。

比较容易糊涂的就是为什么两边可以同时更新下标，而不用在中间更新最优解。因为较低的那个高度决定了容器的高度，所以如果一个容器高度更高了，而另一边的高度与原来一样，装水量肯定是小于之前的最优解的。而如果当前边在之前就比高度大，那么后面也不会更新，会继续重用。
```c++
int maxArea(vector<int> &height) {
    int maxarea = 0;
    int i = 0, j = height.size() - 1;
    while (i < j) {
        int h = min(height[i], height[j]);
        maxarea = max(maxarea, (j - i) * h);
        while (height[i] <= h && i < j) i++;
        while (height[j] <= h && i < j) j--;
    }
    return maxarea;
}
```

# 3. 给定n个非负整数表示每个柱的宽度为1的高程图，计算下雨后能够捕获的水量

同样是装水，这题的容器不是矩形的，每条柱子都对最终装水的量有影响。这个问题的一个特点就是决定当前位置水量的因素只和左边或右边较小的那边最高的那个柱子有关，也就是说用level来保存这个较小柱子中的最高点，就是当前位置的上限，因而当前位置的装水量就是 level-lower 了

```c++
int trap(vector<int> &height) {
    int l = 0, r = height.size() - 1, level = 0, water = 0;
    while (l < r) {
        int lower = height[height[l] < height[r] ? l++ : r--];
        if(lower > level) level = lower;
        water += level - lower;
    }
    return water;
}
```
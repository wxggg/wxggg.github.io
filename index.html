<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <title>wxg的小站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,
            maximum-scale=1">

    <link type="text/css" rel="stylesheet" href="/syntaxhighlighter/styles/shCoreDefault.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/webfonts/ptserif/main.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPerl.js"></script>

    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <style>
        .syntaxhighlighter table {
            font-size: 14px !important;
            overflow: hidden !important;
            background-color: aliceblue !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <header id="header">
        </header>
        <section id="main" class="outer">

            <article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2021/05/火烈鸟的传说.html" style="font-size:1.6em">火烈鸟的传说</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2021/05/火烈鸟的传说.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2021年05月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>东非大裂谷的边缘有一个纳特龙湖，附近是著名的伦盖伊活火山，轮盖伊火山每三十年喷发一次，大量的碳酸盐被释放到纳特隆湖，富含碳酸盐的纳特龙湖水让动物尸体长期保存，看起来像冥湖。然而，纳特龙湖里富含藻类，成为火烈鸟的天堂。火烈鸟吸食水中藻类后，羽毛和眼睛呈现为粉红色，看起来像浴火重生一般。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2021/01/搭建Linux内核开发环境.html" style="font-size:1.6em">搭建Linux内核开发环境</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2021/01/搭建Linux内核开发环境.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2021年01月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>对于Linux内核开发而言使用qemu是很方便的手段，本文主要介绍linux内核开发环境的搭建过程，主要包括内核编译、使用qemu启动编译好的内核，以及构建根文件系统，使用GDB来调试内核等内容。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/12/VFIO-DMA-remapping-and-IO-remapping.html" style="font-size:1.6em">VFIO DMA remapping and IO remapping</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/12/VFIO-DMA-remapping-and-IO-remapping.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>设备直通给虚拟机能够极大提升虚拟机对物理设备访问的性能,本文通过vfio内核模块和qemu用户态实现介绍vfio设备直通时的关键部分,包括:用户态访问设备IO地址空间,DMA重映射,中断重映射等.</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/12/Introduction-to-IOMMU-and-SMMU.html" style="font-size:1.6em">Introduction to IOMMU and SMMU</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/12/Introduction-to-IOMMU-and-SMMU.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>在计算机体系结构中IOMMU（Input Output Memory Management Unit）是将设备直接内存访问（DMA）的IO总线和物理内存连接的内存管理单元，和传统的MMU一样，IOMMU将设备可见的虚拟地址（IOVA）映射到物理地址。不同的平台有不同的IOMMU，如Intel的IOMMU，PCIE图形卡使用的图形重映射表（GART），Arm平台的IOMMU是SMMU（System Memory Management），它们主要功能都是完成设备可见的IOVA到物理地址的映射。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/12/Introduction-VFIO-Device-Passthrough.html" style="font-size:1.6em">Introduction VFIO Device Passthrough</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/12/Introduction-VFIO-Device-Passthrough.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>现代系统大多提供DMA和中断重映射功能来确保I/O设备在有限的范围内运行，比如x86平台的AMD-Vi和Intel VT-d。VFIO（Virtual Function I/O）是一个可以将设备I/O、中断和DMA等能力安全的暴露到用户态空间，从而使用用户态驱动实现设备驱动的框架。通过VFIO进行设备直通到虚拟机，可以获得更高的设备I/O性能。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/06/图论基本算法实现.html" style="font-size:1.6em">图论基本算法实现</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/06/图论基本算法实现.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年06月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>图分为有向图和无向图，相关常见问题及算法有最短路径算法、拓扑排序、关键路径以及最短路径等。本文介绍相关算法的C++实现，完整源码直接参看文末。</p>
<p>与图相关的问题中大多数的节点遍历方式都采用BFS或DFS，顾名思义，广度优先就是先将节点相邻的节点全部遍历，然后递归搜索相邻接点的相邻接点，这一特点与队列比较类似因此在广度优先搜索时一般使用队列作为辅助结构，二叉树的层序遍历实际上就是BFS，而在二叉树的层序遍历中借助的正是队列。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/06/nginx工作模式与惊群现象.html" style="font-size:1.6em">nginx工作模式与惊群现象</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/06/nginx工作模式与惊群现象.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年06月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了nginx的不同工作模式的初始化过程,并针对性的介绍了nginx如何优先处理accept事件,并借助进程锁来解决惊群现象.</p>
<p>Nginx入口在core/nginx.c中，开始时会进行debug和错误信息的初始化，然后读入启动参数，之后进行时间和日志的初始化。然后会初始化一个非常重要的全局变量ngx_cycle，其中保存了全局可用的非常重要的变量，包括内存池、连接池、日志指针等信息。之后会处理读入的参数，进行os相关的初始化，读入并解析配置文件。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/06/Linux下asio如何利用reactor来模拟proactor模式.html" style="font-size:1.6em">Linux下asio如何利用reactor来模拟proactor模式</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/06/Linux下asio如何利用reactor来模拟proactor模式.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年06月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>高并发网络有reactor和proactor两种模式,reactor基于非阻塞io多路复用,本质上属于同步io,而proactor模式则基于异步io. 类unix平台一般都采用reactor模式,如epoll和kqueue等.而Windows平台因为对于reactor模式的支持不好,但是对于异步io有IOCP非常高效. 作为有可能在c++20中进入标准的网络库,asio需要对不同平台都提供支持,这样就造成了只能用一种模式去模拟另一种模式,asio选择在linux下面使用reactor模拟proactor模式.</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/05/平衡二叉树和红黑树.html" style="font-size:1.6em">平衡二叉树和红黑树</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/05/平衡二叉树和红黑树.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年05月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了平衡二叉树（AVL）和红黑树（rbtree）的特点以及实现，具体而言在树的插入删除平衡修复过程介绍篇幅较大。</p>
<p><strong>平衡二叉树（AVL）：</strong> 作为二叉查找树而言，平衡二叉树具备快速查找、插入、删除的特点，并且在平衡二叉树中任何节点的左右子树高度之差不超过1，这一特点使得平衡二叉树具备非常好的平衡性。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/05/b树和b+树实现.html" style="font-size:1.6em">b树和b+树实现</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/05/b树和b+树实现.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年05月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了b/b+树的特点以及为什么b/b+树在数据库中应用广泛，另外介绍了b/b+树基本操作的c++实现，并附完整源代码</p>
<p><strong>共同点：</strong> 首先b/b+树每个节点能够保存多个关键字，数量上限为M-1，这里M为b/b+树的度，限制了键的数量和子节点的数目，当一个非叶子节点有n个键的时候，必定有n+1个子节点。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/04/An-Implementation-Of-Multiprocessor-Linux-译.html" style="font-size:1.6em">An Implementation Of Multiprocessor Linux 译</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/04/An-Implementation-Of-Multiprocessor-Linux-译.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年04月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Intel 奔腾处理器对支持多处理器有着很多内置的组建，包括硬件cache一致性、内置的处理器间中断处理和一套原子的test和set、exchange等类似操作。</p>
<p>内核要正确执行的话就得提供内部的锁来保护自己的各种表，以避免两个进程同时更新它们，比如分配同一个内存块。目前的Unix和类Unix内核有两种策略，传统早期的Unix系统采用粗粒度的锁，用少量的锁来保护整个内核。一些现代的系统使用细粒度的锁，因为细粒度锁有更多的开销其一般只用在多处理器内核和实时内核中。在实时内核中细粒度锁减少了锁被持有的事件，并且减少了严格的延迟时间。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/03/linux-0.x-初始化及进程调度.html" style="font-size:1.6em">linux 0.x 初始化及进程调度</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/03/linux-0.x-初始化及进程调度.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年03月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Linux早期版本变化主要体现在启动及初始化的过程中，这一部分在后面则基本不会改动，前面提到linux-0.01版本的启动过程中包含多次内存移动过程，既有引导扇区将自己移动到0x90000，也有引导扇区将系统加载到0x10000后又移动到0x0000。这样做的目的主要是为了避免在加载的过程中覆盖bios的中断处理程序。这样的特点在后面的linux版本中也得以保留，以linux-0.11为例，主要变化就是将启动过程中的一部分代码抽取出来作为setup.s文件，这是因为引导扇区的大小固定为512B。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/03/linux-0.01-初始化及进程调度.html" style="font-size:1.6em">linux 0.01 初始化及进程调度</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/03/linux-0.01-初始化及进程调度.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年03月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Linux0.01时Linus在1991年发布的第一个Linux版本，最初的这个版本的Linux代码量并不多，但是很多开始的设计在之后的多个版本中都一直保留，一般来说操作系统的设计分块一般不会有大的改动，主要包括启动加载初始化、内存管理、进程调度以及文件系统等。在<a href="https://www.kernel.org/">The Linux Kernel Archive</a>可以下载Linux内核源代码，Linux0.01代码分块来说主要包括boot、fs、include、kernel、lib、mm、tools和Makefile文件，主要包含了启动、文件系统、头文件、内核、内存管理等。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/12/libevent-cpp-5-封装epoll及epoll内核实现原理.html" style="font-size:1.6em">libevent cpp 5 封装epoll及epoll内核实现原理</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/12/libevent-cpp-5-封装epoll及epoll内核实现原理.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>前面介绍了poll和select在内核中的实现原理，可以说本质上两者都是相同的，都是将用户空间的文件描述符及对应事件复制到内核空间，然后在内核空间轮询，如果轮询没有事件，则将当前进程置于该文件描述符的等待队列，如此，在之后该文件进行读写操作时就可以唤醒其等待队列，然后再次轮询时会发现发生了读或者写事件。但是轮询机制在大规模IO复用时会有着明显的缺陷，首先因为poll和select要不断的轮询，所以其时间复杂度为O(n)，随着文件描述符的增多会越来越慢，另外文件描述符的增多也会导致要从用户态拷贝到内核态的数据越来越多，在大规模IO复用中，这种拷贝多次执行显然是难以忍受的，可以说基于poll种种缺点，在Linux-2.6版本左右加入了epoll机制，能够非常高高效的进行IO复用。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/12/libevent-cpp-4-封装poll及poll内核实现原理.html" style="font-size:1.6em">libevent cpp 4 封装poll及poll内核实现原理</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/12/libevent-cpp-4-封装poll及poll内核实现原理.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>随着Linux的更新在linux-2.1.23版本中加入了poll机制，因为poll的加入导致select的实现变得基于poll了，本文在上一个版本的基础上在libevent-cpp中加入了对poll机制的封装。总的来说，主要介绍libevent-cpp poll机制以及Linux内核对poll机制的实现原理，另外还会介绍到内核中select实现因为poll而做的改变。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/12/libevent-cpp-3-读写事件及Linux内核select机制实现原理.html" style="font-size:1.6em">libevent cpp 3 读写事件及Linux内核select机制实现原理</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/12/libevent-cpp-3-读写事件及Linux内核select机制实现原理.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年12月</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>关于libevent除了对于信号和超时的处理，最核心的部分其实是对于多路IO复用的封装。IO复用存在多种方式，包括select、poll、kqueue及epoll等多种接口。libevent的实现中用C语言以类似面向对象的方式来将这多种IO复用方式进行封装，对于我们的libevent-cpp而言，可以直接使用父子继承来实现各种不同的IO方式。本文主要介绍一下select机制以及libevent中使用select来处理IO读写事件的方式，然后深入Linux内核介绍一下select的实现机制。</p>

        </div>

    </div>

</article>
<nav id="page-nav"><a class="extend prev" rel="prev" href="/">&laquo; Prev</a>
<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a>
<a class="page-number" href="/page/3/">3</a>
<a class="page-number" href="/page/4/">4</a>
<a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>

        </section>
        <footer id="footer">

            <div class="outer">
                <div id="footer-info" class="inner">
                    &copy; 2017 ~ now Wang Xingang.&nbsp;, theme by <a href="http://github.com/ppoffice">PPOffice</a>
                </div>
            </div>
        </footer>


    </div>
</body>

</html>

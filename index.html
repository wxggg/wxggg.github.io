<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <title>wxg的小站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,
            maximum-scale=1">

    <link type="text/css" rel="stylesheet" href="/syntaxhighlighter/styles/shCoreDefault.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/webfonts/ptserif/main.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/script.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shCore.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushCpp.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPython.js"></script>
    <script type="text/javascript" src="/syntaxhighlighter/scripts/shBrushPerl.js"></script>

    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <style>
        .syntaxhighlighter table {
            font-size: 14px !important;
            overflow: hidden !important;
            background-color: aliceblue !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <header id="header">
        </header>
        <section id="main" class="outer">

            <article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2021/01/搭建Linux内核开发环境.html">搭建Linux内核开发环境</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2021/01/搭建Linux内核开发环境.html" class="article-date">
                <time itemprop="datePublished">2021年01月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>搭建Linux内核开发环境</p>
<ul><li>Linux 内核编译</li>
<li>Qemu + GDB 启动调试</li>
<li>buildroot 构建根文件系统</li>
</ul>
<h2><a data-uk-modal="{target:'#category-id'}">Linux内核编译</a></h2>

<pre class="brush: ;">
git clone https://github.com/torvalds/linux.git
</pre>
<pre class="brush: ;">
make ARCH=x86_64 x86_64_defconfig
make ARCH=x86_64 menuconfig
</pre>
<p>使用编译选项增加debug信息</p>
<pre class="brush: ;">
Kernel hacking
	Compile-time checks and compiler options  --->
		[*] Compile-time checks and compiler options  --->
		[ ]   Reduce debugging information
		[*]   Provide GDB scripts for kernel debugging
</pre>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/06/图论基本算法实现.html">图论基本算法实现</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/06/图论基本算法实现.html" class="article-date">
                <time itemprop="datePublished">2019年06月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>图分为有向图和无向图，相关常见问题及算法有最短路径算法、拓扑排序、关键路径以及最短路径等。本文介绍相关算法的C++实现，完整源码直接参看文末。</p>
<h2><a data-uk-modal="{target:'#category-id'}">广度优先BFS和深度优先DFS搜索</a></h2>

<p>与图相关的问题中大多数的节点遍历方式都采用BFS或DFS，顾名思义，广度优先就是先将节点相邻的节点全部遍历，然后递归搜索相邻接点的相邻接点，这一特点与队列比较类似因此在广度优先搜索时一般使用队列作为辅助结构，二叉树的层序遍历实际上就是BFS，而在二叉树的层序遍历中借助的正是队列。</p>
<p>与树不同的是，在图的遍历过程中都需要借助一个额外的数据结构来保存已经遍历过的节点，避免节点的重复遍历，这里借助一个名为visited的set来记录。</p>
<p>为了是的bfs能够多次被使用，这里借助template传入一个functor来操作x，便于代码重用。</p>
<pre class="brush: c++;">
template < class Func>
void bfs(node_t start, Func & & func) {
    que.push(start);
    visited.insert(start);
    while (!que.empty()) 
        auto x = que.front();
        func(x);
        que.pop();
        for (auto & & e : adjacent[x])
            if (!visited.count(e->v)) 
                visited.insert(e->v);
                que.push(e->v);
}
</pre>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/06/nginx工作模式与惊群现象.html">nginx工作模式与惊群现象</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/06/nginx工作模式与惊群现象.html" class="article-date">
                <time itemprop="datePublished">2019年06月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了nginx的不同工作模式的初始化过程,并针对性的介绍了nginx如何优先处理accept事件,并借助进程锁来解决惊群现象.</p>
<h2><a data-uk-modal="{target:'#category-id'}">初始化</a></h2>

<p>Nginx入口在core/nginx.c中，开始时会进行debug和错误信息的初始化，然后读入启动参数，之后进行时间和日志的初始化。然后会初始化一个非常重要的全局变量ngx_cycle，其中保存了全局可用的非常重要的变量，包括内存池、连接池、日志指针等信息。之后会处理读入的参数，进行os相关的初始化，读入并解析配置文件。</p>
<h3><a data-uk-modal="{target:'#category-id'}">平滑升级 ngx_add_inherited_sockets</a></h3>

<p>在初始化时一个比较有意思的就是sockets的继承，在进行不重启服务升级nginx时，原来运行的nginx会通过 NGINX 环境变量来来传递需要监听的端口，新启动的nginx会通过  gx_add_inherited_sockets 来使用已经打开的端口，如果不这样的话，会报错端口已经被bind。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/06/Linux下asio如何利用reactor来模拟proactor模式.html">Linux下asio如何利用reactor来模拟proactor模式</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/06/Linux下asio如何利用reactor来模拟proactor模式.html" class="article-date">
                <time itemprop="datePublished">2019年06月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>高并发网络有reactor和proactor两种模式,reactor基于非阻塞io多路复用,本质上属于同步io,而proactor模式则基于异步io. 类unix平台一般都采用reactor模式,如epoll和kqueue等.而Windows平台因为对于reactor模式的支持不好,但是对于异步io有IOCP非常高效. 作为有可能在c++20中进入标准的网络库,asio需要对不同平台都提供支持,这样就造成了只能用一种模式去模拟另一种模式,asio选择在linux下面使用reactor模拟proactor模式.</p>
<p>言归正传,本文就一个主题:在linux下面asio到底是如何借助reactor如epoll来模拟proactor异步模式的.</p>
<h2><a data-uk-modal="{target:'#category-id'}">1. reactor和proactor模式之间到底有什么区别</a></h2>

<p>首先reactor模式依赖于epoll这样的io多路复用机制,能监听大量文件描述符的读写,在有可读写时发生超时或收到信号时从阻塞状态退出,用户程序根据发生的事件进行相应的处理. 本质上来看reactor模式还是同步模式,当前进程一直监控一个事件集合,可读就读,可写就写.</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/05/平衡二叉树和红黑树.html">平衡二叉树和红黑树</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/05/平衡二叉树和红黑树.html" class="article-date">
                <time itemprop="datePublished">2019年05月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了平衡二叉树（AVL）和红黑树（rbtree）的特点以及实现，具体而言在树的插入删除平衡修复过程介绍篇幅较大。</p>
<h2><a data-uk-modal="{target:'#category-id'}">一、平衡二叉树和红黑树</a></h2>

<p><strong>平衡二叉树（AVL）：</strong> 作为二叉查找树而言，平衡二叉树具备快速查找、插入、删除的特点，并且在平衡二叉树中任何节点的左右子树高度之差不超过1，这一特点使得平衡二叉树具备非常好的平衡性。</p>
<p><strong>红黑树（RB）：</strong> 红黑树的特点是利用节点的颜色来控制树的平衡，根节点为黑，其余的节点可以为红或者黑，并且不能够存在父子节点同时为红的情况。最重要的一点是，每个节点到其叶节点的路径上的黑色节点的个数相等，这保证了红黑树具备平衡性。</p>
<p>红黑树广泛应用于Linux内核、STL关联容器及nginx中，具备非常好的查找、插入删除特性。</p>
<h2><a data-uk-modal="{target:'#category-id'}">二、为什么红黑树比平衡二叉树应用更广泛</a></h2>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/05/b树和b+树实现.html">b树和b+树实现</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/05/b树和b+树实现.html" class="article-date">
                <time itemprop="datePublished">2019年05月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了b/b+树的特点以及为什么b/b+树在数据库中应用广泛，另外介绍了b/b+树基本操作的c++实现，并附完整源代码</p>
<h2><a data-uk-modal="{target:'#category-id'}">一、 b树和b+树</a></h2>

<p><strong>共同点：</strong> 首先b/b+树每个节点能够保存多个关键字，数量上限为M-1，这里M为b/b+树的度，限制了键的数量和子节点的数目，当一个非叶子节点有n个键的时候，必定有n+1个子节点。</p>
<p>其次节点内及节点间的键值按顺序排列</p>
<p>除根节点外的其它节点最少有 ceil(M/2)-1 个关键字</p>
<p><strong>不同点：</strong> b树的每个节点都既能保存键(Key)又能保存值(Value)，而b+树只有叶子节点能够保存值，内部节点只保存键和子节点的指针</p>
<p>b+树叶节点采用链表结构</p>
<h2><a data-uk-modal="{target:'#category-id'}">二、 为什么用b/b+树</a></h2>

<p>数据库如MySQL的数据一般放在磁盘中，而读盘的过程包括两次机械运动盘片旋转和磁头移动，这一过程比较耗时，所以对数据的访问性能受限于访问磁盘的次数。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/04/An-Implementation-Of-Multiprocessor-Linux-译.html">An Implementation Of Multiprocessor Linux 译</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/04/An-Implementation-Of-Multiprocessor-Linux-译.html" class="article-date">
                <time itemprop="datePublished">2019年04月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <h2><a data-uk-modal="{target:'#category-id'}">1 背景：Intel多处理器规范</a></h2>

<p>Intel 奔腾处理器对支持多处理器有着很多内置的组建，包括硬件cache一致性、内置的处理器间中断处理和一套原子的test和set、exchange等类似操作。</p>
<h2><a data-uk-modal="{target:'#category-id'}">2 单处理器内核中的互斥</a></h2>

<p>内核要正确执行的话就得提供内部的锁来保护自己的各种表，以避免两个进程同时更新它们，比如分配同一个内存块。目前的Unix和类Unix内核有两种策略，传统早期的Unix系统采用粗粒度的锁，用少量的锁来保护整个内核。一些现代的系统使用细粒度的锁，因为细粒度锁有更多的开销其一般只用在多处理器内核和实时内核中。在实时内核中细粒度锁减少了锁被持有的事件，并且减少了严格的延迟时间。</p>
<p>Linux内核中有些保证必须被确保。除非自愿睡眠，否则在内核中执行的进程不会被另一个内核中执行的进程抢占。这样确保了内核代码块相对于进程而言是原子的，极大地简化了很多操作。其次中断可能会抢占一个正在执行的内核态进程，但是永远都会返回到该进程。一个在内核态中的进程有可能禁用处理器上的中断并保证不会发生这种中断。最后的保证是内核任务不会抢占中断，也就是中断只有可能被其它中断抢占。</p>

        </div>

    </div>

</article><article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h1 itemprop="name">
                <a class="article-title" href="/blogs/2019/03/linux-0.x-初始化及进程调度.html">linux 0.x 初始化及进程调度</a>
            </h1>
        </header>

        <div class="article-meta">
            <a href="/blogs/2019/03/linux-0.x-初始化及进程调度.html" class="article-date">
                <time itemprop="datePublished">2019年03月</time>
            </a>
        </div>

        <div class="article-entry" itemprop="articleBody">
            <p>Linux早期版本变化主要体现在启动及初始化的过程中，这一部分在后面则基本不会改动，前面提到linux-0.01版本的启动过程中包含多次内存移动过程，既有引导扇区将自己移动到0x90000，也有引导扇区将系统加载到0x10000后又移动到0x0000。这样做的目的主要是为了避免在加载的过程中覆盖bios的中断处理程序。这样的特点在后面的linux版本中也得以保留，以linux-0.11为例，主要变化就是将启动过程中的一部分代码抽取出来作为setup.s文件，这是因为引导扇区的大小固定为512B。</p>
<img src="/blogs/2019/03/img/linux-0.x-boot.png" alt="">
<p>到linux-0.99版本的变化主要是在如上setup.s代码获取到显卡数据之后立即进行显示模式的切换，当然这一切仍然在实模式下，因为显示模式的切换是需要调用bios中断的。</p>
<h2><a data-uk-modal="{target:'#category-id'}">1 linux-0.99 初始化</a></h2>

<p>前面setup.s跳转的32位入口是32位汇编程序head.s，head.s需要再次重建gdt、idt等分段和中断机制，之后执行初始化代码也就是start_kernel，相对于0.01版本而言，这里初始化的内容多了硬件中断初始化、软盘初始化、socket初始化、以及进程间通信ipc初始化，并且这里使用idle函数替代了0.01中的pause函数。</p>

        </div>

    </div>

</article><nav id="page-nav"><a class="extend prev" rel="prev" href="/">&laquo; Prev</a>
<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a>
<a class="page-number" href="/page/3/">3</a>
<a class="page-number" href="/page/4/">4</a>
<a class="page-number" href="/page/5/">5</a>
<a class="page-number" href="/page/6/">6</a>
<a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>

        </section>
        <footer id="footer">

            <div class="outer">
                <div id="footer-info" class="inner">
                    &copy; 2019 Wang Xingang.&nbsp; Powered by <a href="https://github.com/wxggg/libevent-cpp"
                        target="_blank">libevent-cpp</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
                </div>
            </div>
        </footer>


    </div>
</body>

</html>
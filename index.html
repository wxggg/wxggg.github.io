<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <title>wxg的小站</title>
    <meta name="viewport" content="width=device-width, initial-scale=0.5,
            maximum-scale=1">

    <link type="text/css" rel="stylesheet" href="/syntaxhighlighter/styles/shCoreDefault.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/webfonts/ptserif/main.css">
    <script src="/js/jquery.min.js"></script>
    <script src="/js/script.js"></script>
    <!-- <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script> -->
	<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <style>
        .syntaxhighlighter table {
            font-size: 14px !important;
            overflow: hidden !important;
            background-color: aliceblue !important;
        }
    </style>
</head>

<body>
    <div id="container">
        <header id="header">
        </header>
        <section id="main" class="outer">

            <article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2021/火烈鸟的传说.html" style="font-size:1.6em">火烈鸟的传说</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2021/火烈鸟的传说.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2021年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>东非大裂谷的边缘有一个纳特龙湖，附近是著名的伦盖伊活火山，轮盖伊火山每三十年喷发一次，大量的碳酸盐被释放到纳特隆湖，富含碳酸盐的纳特龙湖水让动物尸体长期保存，看起来像冥湖。然而，纳特龙湖里富含藻类，成为火烈鸟的天堂。火烈鸟吸食水中藻类后，羽毛和眼睛呈现为粉红色，看起来像浴火重生一般。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2021/搭建Linux内核开发环境.html" style="font-size:1.6em">搭建Linux内核开发环境</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2021/搭建Linux内核开发环境.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2021年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>对于Linux内核开发而言使用qemu是很方便的手段，本文主要介绍linux内核开发环境的搭建过程，主要包括内核编译、使用qemu启动编译好的内核，以及构建根文件系统，使用GDB来调试内核等内容。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/VFIO-DMA-remapping-and-IO-remapping.html" style="font-size:1.6em">VFIO DMA remapping and IO remapping</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/VFIO-DMA-remapping-and-IO-remapping.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>设备直通给虚拟机能够极大提升虚拟机对物理设备访问的性能,本文通过vfio内核模块和qemu用户态实现介绍vfio设备直通时的关键部分,包括:用户态访问设备IO地址空间,DMA重映射,中断重映射等.</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/Introduction-to-IOMMU-and-SMMU.html" style="font-size:1.6em">Introduction to IOMMU and SMMU</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/Introduction-to-IOMMU-and-SMMU.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>在计算机体系结构中IOMMU（Input Output Memory Management Unit）是将设备直接内存访问（DMA）的IO总线和物理内存连接的内存管理单元，和传统的MMU一样，IOMMU将设备可见的虚拟地址（IOVA）映射到物理地址。不同的平台有不同的IOMMU，如Intel的IOMMU，PCIE图形卡使用的图形重映射表（GART），Arm平台的IOMMU是SMMU（System Memory Management），它们主要功能都是完成设备可见的IOVA到物理地址的映射。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2020/Introduction-VFIO-Device-Passthrough.html" style="font-size:1.6em">Introduction VFIO Device Passthrough</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2020/Introduction-VFIO-Device-Passthrough.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2020年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>现代系统大多提供DMA和中断重映射功能来确保I/O设备在有限的范围内运行，比如x86平台的AMD-Vi和Intel VT-d。VFIO（Virtual Function I/O）是一个可以将设备I/O、中断和DMA等能力安全的暴露到用户态空间，从而使用用户态驱动实现设备驱动的框架。通过VFIO进行设备直通到虚拟机，可以获得更高的设备I/O性能。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/平衡二叉树和红黑树.html" style="font-size:1.6em">平衡二叉树和红黑树</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/平衡二叉树和红黑树.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了平衡二叉树（AVL）和红黑树（rbtree）的特点以及实现，具体而言在树的插入删除平衡修复过程介绍篇幅较大。</p>
<p><strong>平衡二叉树（AVL）：</strong> 作为二叉查找树而言，平衡二叉树具备快速查找、插入、删除的特点，并且在平衡二叉树中任何节点的左右子树高度之差不超过1，这一特点使得平衡二叉树具备非常好的平衡性。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/图论基本算法实现.html" style="font-size:1.6em">图论基本算法实现</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/图论基本算法实现.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>图分为有向图和无向图，相关常见问题及算法有最短路径算法、拓扑排序、关键路径以及最短路径等。本文介绍相关算法的C++实现，完整源码直接参看文末。</p>
<p>与图相关的问题中大多数的节点遍历方式都采用BFS或DFS，顾名思义，广度优先就是先将节点相邻的节点全部遍历，然后递归搜索相邻接点的相邻接点，这一特点与队列比较类似因此在广度优先搜索时一般使用队列作为辅助结构，二叉树的层序遍历实际上就是BFS，而在二叉树的层序遍历中借助的正是队列。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/nginx工作模式与惊群现象.html" style="font-size:1.6em">nginx工作模式与惊群现象</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/nginx工作模式与惊群现象.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了nginx的不同工作模式的初始化过程,并针对性的介绍了nginx如何优先处理accept事件,并借助进程锁来解决惊群现象.</p>
<p>Nginx入口在core/nginx.c中，开始时会进行debug和错误信息的初始化，然后读入启动参数，之后进行时间和日志的初始化。然后会初始化一个非常重要的全局变量ngx_cycle，其中保存了全局可用的非常重要的变量，包括内存池、连接池、日志指针等信息。之后会处理读入的参数，进行os相关的初始化，读入并解析配置文件。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/linux-0.x-初始化及进程调度.html" style="font-size:1.6em">linux 0.x 初始化及进程调度</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/linux-0.x-初始化及进程调度.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Linux早期版本变化主要体现在启动及初始化的过程中，这一部分在后面则基本不会改动，前面提到linux-0.01版本的启动过程中包含多次内存移动过程，既有引导扇区将自己移动到0x90000，也有引导扇区将系统加载到0x10000后又移动到0x0000。这样做的目的主要是为了避免在加载的过程中覆盖bios的中断处理程序。这样的特点在后面的linux版本中也得以保留，以linux-0.11为例，主要变化就是将启动过程中的一部分代码抽取出来作为setup.s文件，这是因为引导扇区的大小固定为512B。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/linux-0.01-初始化及进程调度.html" style="font-size:1.6em">linux 0.01 初始化及进程调度</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/linux-0.01-初始化及进程调度.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Linux0.01时Linus在1991年发布的第一个Linux版本，最初的这个版本的Linux代码量并不多，但是很多开始的设计在之后的多个版本中都一直保留，一般来说操作系统的设计分块一般不会有大的改动，主要包括启动加载初始化、内存管理、进程调度以及文件系统等。在<a href="https://www.kernel.org/">The Linux Kernel Archive</a>可以下载Linux内核源代码，Linux0.01代码分块来说主要包括boot、fs、include、kernel、lib、mm、tools和Makefile文件，主要包含了启动、文件系统、头文件、内核、内存管理等。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/b树和b+树实现.html" style="font-size:1.6em">b树和b+树实现</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/b树和b+树实现.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>本文主要介绍了b/b+树的特点以及为什么b/b+树在数据库中应用广泛，另外介绍了b/b+树基本操作的c++实现，并附完整源代码</p>
<p><strong>共同点：</strong> 首先b/b+树每个节点能够保存多个关键字，数量上限为M-1，这里M为b/b+树的度，限制了键的数量和子节点的数目，当一个非叶子节点有n个键的时候，必定有n+1个子节点。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/Linux下asio如何利用reactor来模拟proactor模式.html" style="font-size:1.6em">Linux下asio如何利用reactor来模拟proactor模式</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/Linux下asio如何利用reactor来模拟proactor模式.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>高并发网络有reactor和proactor两种模式,reactor基于非阻塞io多路复用,本质上属于同步io,而proactor模式则基于异步io. 类unix平台一般都采用reactor模式,如epoll和kqueue等.而Windows平台因为对于reactor模式的支持不好,但是对于异步io有IOCP非常高效. 作为有可能在c++20中进入标准的网络库,asio需要对不同平台都提供支持,这样就造成了只能用一种模式去模拟另一种模式,asio选择在linux下面使用reactor模拟proactor模式.</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2019/An-Implementation-Of-Multiprocessor-Linux-译.html" style="font-size:1.6em">An Implementation Of Multiprocessor Linux 译</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2019/An-Implementation-Of-Multiprocessor-Linux-译.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2019年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>Intel 奔腾处理器对支持多处理器有着很多内置的组建，包括硬件cache一致性、内置的处理器间中断处理和一套原子的test和set、exchange等类似操作。</p>
<p>内核要正确执行的话就得提供内部的锁来保护自己的各种表，以避免两个进程同时更新它们，比如分配同一个内存块。目前的Unix和类Unix内核有两种策略，传统早期的Unix系统采用粗粒度的锁，用少量的锁来保护整个内核。一些现代的系统使用细粒度的锁，因为细粒度锁有更多的开销其一般只用在多处理器内核和实时内核中。在实时内核中细粒度锁减少了锁被持有的事件，并且减少了严格的延迟时间。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/自然语言处理札记.html" style="font-size:1.6em">自然语言处理札记</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/自然语言处理札记.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>语言最主要的表达形式就是文字和语音，自然语言处理就是利用计算机自动或半自动地处理大量的文本信息，从中挖掘出有用的信息。自然语言处理研究的一些方面主要包括信息抽取、信息过滤、文档分类、情感分类等方面。自然语言处理中存在的一些基本的问题和困难包括语义歧义问题，比如对于句子</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/自建博客本地中英文搜索引擎.html" style="font-size:1.6em">自建博客本地中英文搜索引擎</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/自建博客本地中英文搜索引擎.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>博客中一直都没有搜索功能，之前学过信息检索的课程，所以现在尝试着利用现代信息检索的方式给博客增加一个本地搜索引擎。主要的步骤包括中英文分词、建立词典和倒排索引表以及根据TF-IDF来进行搜索返回结果的排序。</p>

        </div>

    </div>

</article>
<article id="{article-id}" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">

        <header class="article-header">
            <h3>
		<a class="article-title" href="/blogs/2018/统计学习方法札记.html" style="font-size:1.6em">统计学习方法札记</a>
            </h3>
        </header>

        <!-- <div class="article-meta"> -->
        <!--     <a href="/blogs/2018/统计学习方法札记.html" class="article-date"> -->
        <!--         <time itemprop="datePublished">2018年</time> -->
        <!--     </a> -->
        <!-- </div> -->

        <div class="article-entry" itemprop="articleBody">
            <p>统计学习方法其实就是学习已有的大量数据（输入空间）用模型来总结出规律（特征空间），并对未知类似事件做出预测（输出空间）的一个过程（不知道自己的这个理解有没有问题）。主要的问题包括分类问题和回归问题，核心的步骤其实就是：模型+策略+算法=方法。</p>

        </div>

    </div>

</article>
<nav id="page-nav"><a class="extend prev" rel="prev" href="/">&laquo; Prev</a>
<span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a>
<a class="page-number" href="/page/3/">3</a>
<a class="page-number" href="/page/4/">4</a>
<a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>

        </section>
        <footer id="footer">

            <div class="outer">
                <div id="footer-info" class="inner">
                    &copy; 2017 ~ now Wang Xingang.&nbsp;, theme by <a href="http://github.com/ppoffice">PPOffice</a>
                </div>
            </div>
        </footer>


    </div>
</body>

</html>
